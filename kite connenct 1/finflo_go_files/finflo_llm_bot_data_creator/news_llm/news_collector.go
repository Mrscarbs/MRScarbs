package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"sync"
	"time"

	_ "github.com/go-sql-driver/mysql"
)

type AutoGenerated_news struct {
	Status       string `json:"status"`
	TotalResults int    `json:"totalResults"`
	Articles     []struct {
		Source struct {
			ID   interface{} `json:"id"`
			Name string      `json:"name"`
		} `json:"source"`
		Author      string    `json:"author"`
		Title       string    `json:"title"`
		Description string    `json:"description"`
		URL         string    `json:"url"`
		URLToImage  string    `json:"urlToImage"`
		PublishedAt time.Time `json:"publishedAt"`
		Content     string    `json:"content"`
	} `json:"articles"`
}

var mut sync.Mutex

func main() {
	var wg sync.WaitGroup
	file, err10 := os.Create("news_docs.txt")
	if err10 != nil {
		log.Println(err10)
	}

	fmt.Println("initializing news")
	api_key, log_main := get_api_key(5)
	fmt.Println(api_key)
	var list_countries = []string{"in", "us", "cn", "ru", "gb", "sg"}

	for i := 0; i < len(list_countries); i++ {
		wg.Add(1)
		go get_news(log_main, list_countries[i], api_key, file, &wg)
	}
	var keyword []string = []string{"bitcoin", "indian stocks", "comodities", "forex", "crypto", "ethereum", "cardano", "american stocks", "nvedia", "amd", "ai", "ml", "google", "microsoft", "tesla", "feds", "inflation"}

	for z := 0; z < len(keyword); z++ {
		wg.Add(1)
		go get_news_everything(log_main, list_countries[1], api_key, file, keyword[z], &wg)
	}
	wg.Wait()
	reader()

}

func get_api_key(api_id int) (string, *os.File) {
	log_file, _ := os.Create("log_news_contest.log")
	log.SetOutput(log_file)
	var api_key string
	var secret_key string
	var api_provider string
	var access_Token string
	var last_purchase_time int
	var first_purchase_time int
	var hstorical int
	var instrument_type string
	var prev_api_id int

	db, err := sql.Open("mysql", "root:Karma100%@tcp(localhost:3306)/finflo_base_db")
	if err != nil {
		fmt.Println(err)
	}
	err2 := db.QueryRow("call stp_get_api_config(?)", api_id).Scan(&api_key, &secret_key, &api_provider, &access_Token, &last_purchase_time, &first_purchase_time, &hstorical, &instrument_type, &prev_api_id)
	if err2 != nil {
		fmt.Println(err2)
	}
	return api_key, log_file
}

func get_news(log_main *os.File, country string, api_key string, file *os.File, wg *sync.WaitGroup) {
	url := fmt.Sprintf("https://newsapi.org/v2/top-headlines?country=%s&category=business&apiKey=%s", country, api_key)
	fmt.Println(url)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Println(log_main)

	}
	response, err2 := http.DefaultClient.Do(req)
	if err2 != nil {
		log.Println(err2)
	}

	databytes, err3 := io.ReadAll(response.Body)
	if err3 != nil {
		log.Println(err3)
	}

	fmt.Println(string(databytes))
	var news AutoGenerated_news
	err5 := json.Unmarshal(databytes, &news)
	if err5 != nil {
		log.Println(err5)
	}

	articles := news.Articles
	mut.Lock()
	for _, value := range articles {
		author := value.Author
		source := value.Source.Name
		title := value.Title
		url := value.URL
		description := value.Description
		content := value.Content

		news_llm_contex := fmt.Sprintf("the source of the news is %s and the place of the source is %s , the author of the news is %s, the title is : %s, find the complete news here %s, description :  %s, content :  %s", source, country, author, title, url, description, content)

		file_writer(file, news_llm_contex)
	}
	mut.Unlock()
	wg.Done()
}

func get_news_everything(log_main *os.File, country string, api_key string, file *os.File, search string, wg *sync.WaitGroup) {

	url := fmt.Sprintf("https://newsapi.org/v2/everything?q=%s&apiKey=%s", search, api_key)
	fmt.Println(url)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Println(log_main)

	}
	response, err2 := http.DefaultClient.Do(req)
	if err2 != nil {
		log.Println(err2)
	}

	databytes, err3 := io.ReadAll(response.Body)
	if err3 != nil {
		log.Println(err3)
	}

	fmt.Println(string(databytes))
	var news AutoGenerated_news
	err5 := json.Unmarshal(databytes, &news)
	if err5 != nil {
		log.Println(err5)
	}

	articles := news.Articles
	mut.Lock()
	for _, value := range articles {
		author := value.Author
		source := value.Source.Name
		title := value.Title
		url := value.URL
		description := value.Description
		content := value.Content

		news_llm_contex := fmt.Sprintf("the source of the news is %s, the author of the news is %s, the title is : %s, find the complete news here %s, description :  %s, content :  %s", source, author, title, url, description, content)

		file_writer(file, string(news_llm_contex))
		fmt.Println(search)
	}
	mut.Unlock()
	wg.Done()
}

func file_writer(file *os.File, content string) {
	io.WriteString(file, content)
}

func reader() {
	databytes, err := os.ReadFile("news_docs.txt")
	if err != nil {
		log.Println(err)
	}

	fmt.Println(string(databytes))
	fmt.Println("done reading news")
}
